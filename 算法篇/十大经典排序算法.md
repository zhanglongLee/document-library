# 前言

为了更好的准备前端面试，算法内功也不能落下。先立个flag，每天学习一种排序算法。

# 1. 如何分析一个算法

复杂度分析

- 时间复杂度： 一个算法执行所耗费的时间。
- 空间复杂度：运行完一个程序所需内存的大小。

还要从`执行效率`、`内存消耗`、`稳定性`三方面入手。

## 1.2 执行效率

**1. 最好情况、最坏情况、平均情况时间复杂度**

我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。
除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

**2. 时间复杂度的系数、常数 、低阶**

我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。

但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

**3. 比较次数和交换（或移动）次数**

这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。

所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

## 1.2 内存消耗

即空间复杂度

专业术语包括：

- **内排序**：所有排序操作都在内存中完成；
- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
- **原地排序**：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

## 1.3 稳定性

- 稳定：如果待排序的序列中存在值`相等`的元素，经过排序之后，相等元素之间原有的先后顺序`不变`。
  比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 的前面；
- 不稳定：如果待排序的序列中存在值`相等`的元素，经过排序之后，相等元素之间原有的先后顺序`改变`。
  比如：a 原本在 b 的前面，而 a = b，排序之后， a 在 b 的后面；

# 2. 十大经典排序

## 2.1 冒泡排序（Bubble Sort）

**简介**
冒泡排序（Bubble Sort），重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），故名“冒泡排序”。

**动画**

![冒泡排序](D:\前端学习\zhanglongli\document-library\算法篇\十大经典排序算法.assets\冒泡排序.gif)

**思想**

- 冒泡排序只会操作相邻的两个数据。
- 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n -1次（第n-1次的排序时，只剩下两个数，排序完这两个数都可以确定位置），就完成了 n 个数据的排序工作。

**特点**

- 优点：排序算法的基础，简单实用易于理解。
- 缺点：比较次数多，效率较低。

![image-20211201103519128](D:\前端学习\zhanglongli\document-library\算法篇\十大经典排序算法.assets\image-20211201103519128.png)

上图每一行的绿色区域表示下一次需要排序的数

假设`i=0`，可以看出`i`的取值范围是`arr.length-1-i`，因为每排完一次序，都有1个数确定位置了，范围应该要减去这个数。

第几次 0 1 2 3 4

已确定 0 1 2 3 4 =》i

**代码实现**

```javascript
// 冒泡排序（未优化）
let arr = [5, 4, 3, 2, 1]
const BubbleSort = arr => {
    console.time("改进前冒泡排序耗时")
    const length = arr.length
    if (length <= 1) { return }
    // i < length - 1 是因为外层只需要 length - 1次就排好了，最后一次排序可以确定最后两个数的位置
    for (let i = 0; i < length - 1; i++) {
        // j < length - 1 -i 是因为每次排完一次序，都有i个数被确定，范围应该减去i
        for (let j = 0; j < length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
        }
    }
    console.log("改进前 arr ：", arr)
    console.timeEnd("改进前冒泡排序耗时")
}
```

优化：当某次冒泡排序已经没有数据交换时，可以说明这个数组已经完全排序好，不需要继续执行后面的排序。

```javascript
// 冒泡排序（优化版）
const optimizedBubbleSort = arr => {
    console.time("改进后冒泡排序耗时")
    const length = arr.length
    if (length <= 1) { return }
    // i < length - 1 是因为外层只需要 length - 1次就排好了，最后一次排序可以确定最后两个数的位置
    for (let i = 0; i < length - 1; i++) {
        let hasChange = false //是否发生数据交换
        // j < length - 1 -i 是因为每次排完一次序，都有i个数被确定，范围应该减去i
        for (let j = 0; j < length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
                hasChange = true
            }
        }
        // 如果没有发生数据交换，代表已经完成，跳出外层循环，结束排序
        if(!hasChange){break}
    }
    console.log("改进后 arr ：", arr)
    console.timeEnd("改进后冒泡排序耗时")
}
```

**测试**

```javascript
let arr = [1,2,3,5,4]
BubbleSort(arr)
console.log('--------');
optimizedBubbleSort(arr)
```

![image-20211201105907806](D:\前端学习\zhanglongli\document-library\算法篇\十大经典排序算法.assets\image-20211201105907806.png)

**分析**

- 第一，冒泡排序是原地排序算法吗 ？
  冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个`原地`排序算法。
- 第二，冒泡排序是稳定的排序算法吗 ？
  在冒泡排序中，只有交换才可以改变两个元素的前后顺序。
  为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。
  所以冒泡排序是`稳定`的排序算法。
- 第三，冒泡排序的时间复杂度是多少 ？
  最佳情况：T(n) = O(n)，当数据已经是正序时。
  最差情况：T(n) = O(n2)，当数据是反序时。
  平均情况：T(n) = O(n2)。



### 2.2 插入排序

插入排序又为分为 **直接插入排序** 和优化后的 **拆半插入排序** ，我们通常说的插入排序是指直接插入排序。

#### 2.2.1 直接插入排序

**思想**

一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张牌，就扫描自己的牌，把新牌插入到相应的位置。

插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置插入。

**步骤**

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一个位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后面；
- 重复步骤2-5；

**代码实现**

```javascript
const insertionSort = (arr) => {
    let len = arr.length
    if (len < 2) {
        return
    }
    let preIndex, current;
    // 遍历所有遍历
    // 第一个元素被认为已排序，所以从下标为1的元素开始向已排序的数据从右往左扫描
    // 如果已排序的数大于当前元素，则已排序的数
    for (let i = 1; i < len; i++) {
        preIndex = i - 1;// 带比较元素的下标
        current = arr[i];// 当前元素
        while (preIndex >= 0 && arr[preIndex] > current) {
            // 已排序的元素向后移动
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        if (preIndex + 1 != i) {
            // 防止赋值给自己
            arr[preIndex + 1] = current;// 将当前元素插入预留空位
            console.log("arr:", arr);
        }
    }
}
```

**测试**

```javascript
// 测试
const array = [5, 4, 3, 2, 1];
console.log("原始 array :", array);
insertionSort(array);
// 原始 array:    [5, 4, 3, 2, 1]
// array:  		 [4, 5, 3, 2, 1]
// array:  		 [3, 4, 5, 2, 1]
// array: 		 [2, 3, 4, 5, 1]
// array:  		 [1, 2, 3, 4, 5]
```

**分析**

- 第一，插入排序时原地排序算法吗？

  插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，所以这是一个`原地`排序算法。

- 第二，插入排序时稳定的排序算法吗？

  在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是`稳定`的排序算法。

- 第三，插入排序的时间复杂度是多少？

  最佳情况：T(n) = O(n)，当数据已经是正序时。

  最差情况：T(n) = O(n2)，当数据是反序时。

  平均情况：T(n) = O(n2)。

**动图**

![直接插入排序](D:\前端学习\zhanglongli\document-library\算法篇\十大经典排序算法.assets\直接插入排序.gif)

#### 2.2.2 拆半插入

插入排序也有一种优化算法，叫做`拆半插入`

**思想**

在插入到已排序的数据时采用来折半查找（二分查找），取已经排好序的数组的中间元素，与插入的数据进行比较，如果比插入的数据大，那么插入的数据肯定属于前半部分，否则属于后半部分，依次不断缩小范围，确定要插入的位置。

**步骤**

- 假设low=0，high=i-1;
- 取`0~i-1`的中间点(m = Math.floor((i-1)/2)，array[i]与array[m] 进行比较，若array[i] < array[m]，则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间，high=m-1；反之，则说明它应该处于数组的 m ~ i-1 索引之间，low=m+1;
- 将索引大于low的元素往后移动一位;
- 将当前元素插入到索引为low的位置中;

**代码**

```javascript
const optimizedInsertionSort = (arr) => {
    let len = arr.length
    if (len < 2) {
        return
    }
    let low, high
    for (let i = 1; i < len; i++) {
        let temp = arr[i] //当前元素
        // 定义边界，低区和高区
        low = 0
        high = i - 1
        // 使用二分查找扫描已排序的序列
        while (low <= high) {
            let m = Math.floor((low + high) / 2)
            if (arr[m] > arr[i]) {
                // 说明当前元素应该在中间值的左边区间，高区 = m - 1
                high = m - 1
            } else {
                // 说明当前元素应该在中间值的右边区间，低区 = m + 1
                low = m + 1
            }
        }
        // 遍历索引大于low的元素，并将它们往后位移一位
        for (let j = i; j > low; j--) {
            arr[j] = arr[j - 1]
        }
        if (low != i) {
            // 避免自己赋值给自己
            // 插入当前元素
            arr[low] = temp
            console.log("arr：", arr);
        }
    }
}
```

**测试**

```javascript
const array = [5, 4, 3, 2, 1];
console.log("原始 array :", array);
optimizedInsertionSort(array);
// 原始 array:    [5, 4, 3, 2, 1]
// array:  		 [4, 5, 3, 2, 1]
// array:  		 [3, 4, 5, 2, 1]
// array: 		 [2, 3, 4, 5, 1]
// array:  		 [1, 2, 3, 4, 5]
```



# 参考文献

- [JavaScript 数据结构与算法之美 - 十大经典排序算法汇总](https://github.com/biaochenxuying/blog/issues/42#)
- [排序算法——冒泡排序原理动图详解及实现](https://blog.csdn.net/qq_43792385/article/details/99466879)
