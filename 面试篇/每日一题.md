# 1.commonjs的模块机制和es6模块机制的区别?

## 区别

1. CommonJS 是运行时加载，ES6 是编译时加载。原因：CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
2. 语法不同。commonjs使用`require、module.exports`关键字导入导出， es模块使用`import、export`关键字导入导出。
3. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。注意：CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
4. CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。

**参考文章**

- [commonJS和ES6模块化的区别](https://blog.csdn.net/xieanna123/article/details/110952381)

# 2.Object.defineProperty和Proxy的区别，Vue3 为什么用Proxy替代Object.defineProperty？

## 区别

### Object.defineProperty ：

- 必须遍历对象的每个属性，不能监听对象本身；
- 无法监听到对象新增的属性；
- 无法监听数组变化（数组的这些方法不能触发set:push、pop、shift、unshift、splice、sort、reverse）。Vue对其变异方法进行重写；
- Vue2使用Object.defineProperty对所有对象的属性进行遍历，性能较差；

### Proxy：

- 监听对象本身；
- 可以监听到对象新增的属性；
- 可以监听到数组变化；
- 性能较好；
- 监听的事件类型更多；

## Vue3使用Proxy的原因：

- 可以直接监听对象本身，不需要遍历循环对象的每个属性，减少代码体积。
- 解决Vue无法监听到对象新增的属性的问题；

**参考文章**

- [Vue3 为什么要用 Proxy 代替 Object.defineProperty 实现响应式](https://www.jianshu.com/p/8cde476238f0)



# 3.async和defer的区别 ?

## 页面的加载和渲染过程

1. 浏览器通过HTTP协议请求服务器，获取HMTL文档并开始从上到下解析，构建DOM；
2. 在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；
3. 样式文件下载完成后，构建CSSDOM；脚本文件下载完成后，解释并执行，然后继续解析文档构建DOM；
4. 完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口 。

在这个过程中，脚本文件的下载和执行是与文档解析同步进行，也就是说，它会阻塞文档的解析。

## async

1.加载JS不阻塞DOM渲染过程，执行JS会阻塞DOM渲染过程。
2.一定会在load事件之前执行，可能会在DOMContentLoaded之前或之后执行。

情况1： HTML 还没有被解析完的时候，async脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件。如下图所示：
![image-20220104162634305](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162634305.png)
情况2： HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件。如下图所示：
![image-20220104162657199](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162657199.png)
总之， DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 脚本。

## defer

1.加载JS不阻塞DOM渲染过程，JS脚本会等到DOM渲染完成后才会执行。
2.DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。

情况1：HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件。如下图所示
![image-20220104162715624](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162715624.png)
情况2：HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件。如下图所示：
![image-20220104162726574](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162726574.png)

《JavaScript高级程序设计》一书的说法是:“按照h5规范，两个defer脚本会安装它们出现的先后顺序执行，两个脚本会在DOMContentLoaded之前执行。但事实上，defer脚本不一定会按顺序执行，也不一定会在DOMContentLoaded之前执行。”

**参考文章**

- [async、defer与DOMContentLoaded的执行先后关系](https://blog.csdn.net/zyj0209/article/details/79698430)
- [defer和async的区别](https://www.jianshu.com/p/c7c331ea4fe8)