# 1.commonjs的模块机制和es6模块机制的区别?

1. CommonJS 是运行时加载，ES6 是编译时加载。原因：CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
2. 语法不同。commonjs使用`require、module.exports`关键字导入导出， es模块使用`import、export`关键字导入导出。
3. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。注意：CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
4. CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。

**参考文章**

- [commonJS和ES6模块化的区别](https://blog.csdn.net/xieanna123/article/details/110952381)

# 2.Object.defineProperty和Proxy的区别，Vue3 为什么用Proxy替代Object.defineProperty？

## 2.1 区别

### Object.defineProperty ：

- 必须遍历对象的每个属性，不能监听对象本身；
- 无法监听到对象新增的属性；
- 无法监听数组变化（数组的这些方法不能触发set:push、pop、shift、unshift、splice、sort、reverse）。Vue对其变异方法进行重写；
- Vue2使用Object.defineProperty对所有对象的属性进行遍历，性能较差；

### Proxy：

- 监听对象本身；
- 可以监听到对象新增的属性；
- 可以监听到数组变化；
- 性能较好；
- 监听的事件类型更多；

## 2.2 Vue3使用Proxy的原因：

- 可以直接监听对象本身，不需要遍历循环对象的每个属性，减少代码体积。
- 解决Vue无法监听到对象新增的属性的问题；

**参考文章**

- [Vue3 为什么要用 Proxy 代替 Object.defineProperty 实现响应式](https://www.jianshu.com/p/8cde476238f0)



# 3.async和defer的区别 ?

## 3.1 页面的加载和渲染过程

1. 浏览器通过HTTP协议请求服务器，获取HMTL文档并开始从上到下解析，构建DOM；
2. 在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；
3. 样式文件下载完成后，构建CSSDOM；脚本文件下载完成后，解释并执行，然后继续解析文档构建DOM；
4. 完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口 。

在这个过程中，脚本文件的下载和执行是与文档解析同步进行，也就是说，它会阻塞文档的解析。

## 3.2 async

1.加载JS不阻塞DOM渲染过程，执行JS会阻塞DOM渲染过程。
2.一定会在load事件之前执行，可能会在DOMContentLoaded之前或之后执行。

情况1： HTML 还没有被解析完的时候，async脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件。如下图所示：
![image-20220104162634305](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162634305.png)
情况2： HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件。如下图所示：
![image-20220104162657199](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162657199.png)
总之， DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 脚本。

## 3.3 defer

1.加载JS不阻塞DOM渲染过程，JS脚本会等到DOM渲染完成后才会执行。
2.DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。

情况1：HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件。如下图所示
![image-20220104162715624](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162715624.png)
情况2：HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件。如下图所示：
![image-20220104162726574](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220104162726574.png)

《JavaScript高级程序设计》一书的说法是:“按照h5规范，两个defer脚本会安装它们出现的先后顺序执行，两个脚本会在DOMContentLoaded之前执行。但事实上，defer脚本不一定会按顺序执行，也不一定会在DOMContentLoaded之前执行。”

**参考文章**

- [async、defer与DOMContentLoaded的执行先后关系](https://blog.csdn.net/zyj0209/article/details/79698430)
- [defer和async的区别](https://www.jianshu.com/p/c7c331ea4fe8)

# 4.JS垃圾回收机制

## 4.1 垃圾回收机制

**JavaScript 具有自动垃圾收集机制**（GC：GarbageCollecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。

## 4.2 内存生命周期

JS环境中分配的内存一般有如下生命周期：

1. 内存分配：当我们申明变量、函数、对象,并执行的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

## 4.3 垃圾回收机制策略

### **4.3.1 标记清除算法**

JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

该算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将**定期从根开始**（在JS中就是全局对象）扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

**何时开始垃圾回收?**
通常来说，在使用标记清除算法时，未引用对象并不会被立即回收。取而代之的做法是，垃圾对象将一直累计到内存耗尽为止。**当内存耗尽时，程序将会被挂起，垃圾回收开始执行。**

**标记清除算法缺陷**

- 那些无法从根对象查询到的对象都将被清除
- 垃圾收集后有可能会造成大**量的内存碎片**

### 4.3.2 **引用计数算法**

此算法把“对象是否不再需要”简化定义为“**对象有没有其他对象引用到它**”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

**引用计数**的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

**引用计数缺陷**

该算法有个限制：无法处理循环引用。如果两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

### 4.3.3 Chrome V8 垃圾回收算法

V8 引擎采用的是分代式垃圾回收机制。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（**新生代**young generation），少回收「持久对象区」（**老生代** tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。

**V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。**如下图：

![image-20220105175758859](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220105175758859.png)

#### **V8新生代算法（Scavenge）**

**晋升:**

对象从新生代中移动到老生代中的过程称为晋升。

**晋升条件:**

1. 对象是否经历过Scavenge回收。
2. 一个是To空间的内存占用比超过25%限制。

**算法过程：**

将新生代内存平分为**From空间（处于使用状态的空间）、To空间（处于闲置状态的空间）**。分配对象时，现在From空间分配。开始进行垃圾回收时，会检查From空间中的存活对象。**如果达到晋升条件的对象，会移动到老生代中，完成晋升。**将这些存活对象复制到To空间中，而(From空间内的)非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换(**即以前的From空间释放后变为To;To空间在复制存活的对象后,变为From空间**)。简而言之，在垃圾回收过程中，就是通过将存活对象在两个半空间之间进行复制。

**Scavenge算法缺点:**
**只能使用堆内存中的一半**，这是由划分空间和复制机制所决定的。

**Scavenge算法优点：**

1. 只处理新生代存活的对象（命周期短的场景存活对象只占少部分），**时间效率高**。

#### **V8老生代算法（Mark-Sweep && Mark-Compact）**

**Mark-Sweep:**

Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。**Mark-Sweep在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。**

**Mark-Sweep的缺点:**

标记清除完成后，内存空间会出现不连续的状态（**内存碎片**）。

**Mark-Compact:**

为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理的意思。**在标记清除的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。**完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。

![image-20220105175717945](D:\前端学习\zhanglongli\document-library\面试篇\每日一题.assets\image-20220105175717945.png)

#### **增量式标记回收(Incremental Marking)**

**垃圾回收的3种基本算法都需要将应用逻辑暂停下来**，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。

增量式标记回收是**拆分为许多小“步进”，每做完一“步进”就让js应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。**

**优点：**

- V8在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。

**参考文章**

- [前端面试查漏补缺--(二) 垃圾回收机制](https://juejin.cn/post/6844903781079973902#heading-13)

