# 1.事件流是什么？

当我们在网页上进行某些类型的交互时，也会触发事件，比如在某些内容上的点击、鼠标经过某个特定元素或按下键盘上的某些按键。当一个节点产生一个事件时，该事件会在元素结点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程称为`DOM事件流`。

事件流描述的就是从页面中接收事件的顺序。而早期的IE和Netscape提出了完全相反的事件流概念，IE事件流是`事件冒泡`，而Netscape的事件流就是`事件捕获`。

DOM2级事件规定的事件流包括三个阶段：

1. 事件捕获阶段 
2. 处于目标阶段 
3. 事件冒泡阶段

其中定义了两个方法：

AddEventListener() ---添加事件侦听器

RemoveEventListener() ---删除事件侦听器

函数均有3个参数， 第一个参数是要处理的`事件名`  第二个参数是作为事件处理程序的`函数`  第三个参数是一个`boolean值`，默认false表示使用冒泡机制，true表示捕获机制。

加上stopPropagation函数，阻止程序冒泡。

```html
<body>
    <div class="parent">
        <div class="son"></div>
    </div>
    <script>
        let parent = document.querySelectorAll(".parent")[0]
        let son = document.querySelectorAll(".son")[0]
        let showParent = function () {
            alert("parent")
        }
        let showSon = function (e) {
            // 阻止事件冒泡
            e.stopPropagation()
            alert("son")
        }
        son.addEventListener("click",showSon,false)// son
        parent.addEventListener("click",showParent,false)// parent
    </script>
</body>
```

# 2.null和undefined的区别？

1. undefined表示变量声明了没有赋值，转换为数值时为NaN。
2. Null表示“空”的对象，表示此处不应该有值，转换为数值时为0。

> 使用场景细分如下：

- `null`：

1. `Number(null)` 得到 `0`。
2. 作为函数的参数，表示该函数的参数不是对象。
3. 作为对象原型链的终点。`Object.prototype.__proto__ === null`。

- `undefined`：

1. `Number(undefined)` 得到 `NaN`。
2. 变量被声明但是没有赋值，等于 `undefined`。
3. 调用函数时，对应的参数没有提供，也是 `undefined`。
4. 对象没有赋值，这个属性的值为 `undefined`。
5. 函数没有返回值，默认返回 `undefined`。

# 3.原型和原型链

每个函数都有一个`prototype`属性，这个属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型。

每个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就叫做原型。

每个对象都有一个`__protp__`属性，这个属性指向了构造函数的`prototype`属性。

构造函数的`prototype`属性中有个`constructor`属性指向构造函数本身。

因为原型也是对象，所以也有`__protp__`属性，指向的是`Object.protype`属性，`Object.protype`也是对象，也有`__protp__`属性，指向的是null，也就是原型链的顶端。

每个实例对象在查找属性的时候，如果对象本身不存在，就通过`__protp__`属性向原型对象上查询，如果没有找到就再向原型对象的`__protp__`属性查询，直到原型链顶端，查询不到返回undefined。这个查询的链条成为原型链。

所有得出以下关系图：

![image-20211119000828228](D:\前端学习\zhanglongli\document-library\javaScript\基础.assets\image-20211119000828228.png)

# 4.继承的方式有哪些？以及优缺点？

## 4.1 原型链继承

优点：

- 实例可以共享原型上的属性和方法

缺点：

- 引用类型的属性被所有实例共享
- 在创建Child的实例时，不能向Parent传参

```javascript
// 原型链继承
function Parent() {
    this.name = ['张三','李四']
}
function Child() {

}
Child.prototype = new Parent()
var child1 = new Child()
var child2 = new Child()
child1.name.push('王五')
console.log(child1.name)// ["张三", "李四", "王五"]
console.log(child2.name)// ["张三", "李四", "王五"]
```



## 4.2 借用构造函数继承（经典基础）

优点：

- 避免了引用类型的属性被所有实例共享
- 可以在Child 中 向Parent 传参

缺点：

- 方法都在构造函数中定义，每次创建实例都会创建一遍方法

```javascript
// 借用构造函数继承
function Parent(name) {
    this.name = name
    this.info = ['张三','李四']
}
function Child(name) {
    Parent.call(this,name)
}
var child1 = new Child('张三')
var child2 = new Child('李四')
child1.info.push('王五')
console.log(child1.info)// ["张三", "李四", "王五"]
console.log(child2.info)// ["张三", "李四"]
```

## 4.3 组合继承

> 原型链继承和经典继承双剑合璧

优点：

- 避免了引用类型的属性被所有实例共享
- 可以在`Child` 中 向`Parent` 传参
- 实例可以共享原型上的属性和方法

缺点：

- `Parent`构造函数被执行了两次。通过原型链继承方式在`Child.prototype`属性中存在`Parent`的属性；通过借用构造函数继承方式在`Child`中存在`Parent`的属性；并且会被`Child`实例的属性所覆盖，存在内存浪费。

```javascript
// 组合式继承
function Parent(name) {
	this.name = name
	this.info = ['张三','李四']
}
Parent.prototype.say = function(){
	console.log("hello")
}
function Child(name) {
	Parent.call(this,name)
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
var child1 = new Child('张三')
var child2 = new Child('李四')
child1.info.push('王五')
console.log(child1.info)// ["张三", "李四", "王五"]
console.log(child2.info)// ["张三", "李四"]
console.log(child1);
console.log(child2);
```

![image-20211119005216989](D:\前端学习\zhanglongli\document-library\javaScript\基础.assets\image-20211119005216989.png)



## 4.4 原型式继承

就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

ES5添加了`Object.create()`实现了这里`object()`的功能，规范了原型式继承，
该方法接收两个参数：
1、新对象的原型对象；
2、新对象的`定义额外属性的对象`；

缺点：

- 引用类型的属性被所有实例共享

![image-20211119231541726](D:\前端学习\zhanglongli\document-library\javaScript\基础.assets\image-20211119231541726.png)



## 4.5 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

优点：

- 避免了引用类型的属性被所有实例共享
- 可以在Child 中 向Parent 传参

缺点：

- 方法都在构造函数中定义，每次创建实例都会创建一遍方法

![image-20211119231822722](D:\前端学习\zhanglongli\document-library\javaScript\基础.assets\image-20211119231822722.png)



## 4.6 寄生组合式继承

优点：

- 避免了引用类型的属性被所有实例共享
- 可以在`Child` 中 向`Parent` 传参
- 实例可以共享原型上的属性和方法
- 优化了组合式及成果`Parent`函数被执行两次的问题

![image-20211119233015194](D:\前端学习\zhanglongli\document-library\javaScript\基础.assets\image-20211119233015194.png)

# 5.执行上下文

## 5.1 概念

执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。

## 5.2 执行上下文的类型

JavaScript 中有三种执行上下文类型。

- **全局执行上下文** — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 `this` 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
- **函数执行上下文** — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。
- **Eval 函数执行上下文** — 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 `eval`，所以在这里我不会讨论它。

## 5.3 怎么创建上下文

> 创建时会执行以下：

1. **this** 值的决定，即我们所熟知的 **This 绑定**。
2. 创建**词法环境**组件。（负责处理 `let` 和 `const` 定义的变量）
3. 创建**变量环境**组件。（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）

参考链接：[面试官：说说执行上下文吧](https://juejin.cn/post/6844904158957404167#heading-5)

# 6.闭包

## 6.1  闭包的概念

> 闭包是一个有权访问其他函数作用域内的变量的函数。

由于在JS中，变量的作用域属于函数的作用域。函数在执行完之后，作用域会被销毁，内存也随之回收。但是闭包是创建在一个函数内部的子函数，由于其能访问上级作用域的原因，上级函数执行完之后作用域不会被销毁，此时子函数——也就是闭包，它拥有访问上级作用域的变量的权限，即使上级函数执行完之后作用域的变量也不会被销毁。

## 6.2 解决问题

- 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
- 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化。

## 6.3 应用场景

1. Ajax请求的成功回调
2. 事件绑定的回调方法
3. setTimeout的延时回调
4. 一个函数内部返回另一个匿名函数

## 6.4  缺点

当内部函数被保存到外部时就会生成闭包 闭包会导致原有作用域链不释放 造成能存泄露

参考链接：[当面试官问你闭包时，他究竟想听到些什么？](https://zhuanlan.zhihu.com/p/29157822)

# 7.作用域和作用域链

## 7.1 概念

JS作用域是JS识别变量的范围，作用域链是JS查找变量的顺序

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由`多个执行上下文的变量对象构成的链表`就叫做`作用域链`。

## 7.2 作用域的分类

1. **全局作用域**：也就是定义在window下的变量范围，在任何地方都可以访问，
2. **局部作用域**：是只在函数内部定义的变量范围

3. **块级作用域**：简单来说用let和const在任意的代码块中定义的变量都认为是块级作用域中的变量，例如在for循环中用let定义的变量，在if语句中用let定义的变量等等

> 尽量不要使用全局变量，因为容易导致全局的污染，命名冲突，对bug查找不利。

## 7.3 函数的作用域链创建

### 7.3.1 函数创建

>  函数的作用域在函数定义的时候就决定了。

这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！

举个例子：

```javascript
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为：

```javascript
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```

### 7.3.2 函数激活

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。

这时候执行上下文的作用域链，我们命名为 Scope：

```javascript
Scope = [AO].concat([[Scope]]);
```

至此，作用域链创建完毕。



参考链接：[JavaScript深入之作用域链](https://github.com/mqyqingfeng/Blog/issues/6#)

# 8.立即执行函数表达式（IIFE）

## 8.1 概念

顾名思义，它定义了一个匿名函数表达式，并且立即执行。

**代码：**

```javascript
// 官方推荐这种写法
(function(){
    alert("立即执行啦");
}())

// 这种写法也行
(function(){
    alert("hello world！");
})()
```

## 8.2 作用

创建一个独立的作用域

**好处：**

- 防止变量弥散到全局作用域，避免各js库命名冲突
- 隔离作用域，防止被污染
- 避免闭包造成引用变量无法释放

## 8.3 使用场景

一般用于框架、插件开发

**参考链接**

- [立即执行函数表达式(IIFE)](https://segmentfault.com/a/1190000007569312)
- [前端基础面试题(JS部分)](https://zhuanlan.zhihu.com/p/28428367)

# 9.this指向

## 9.1 概念

`this`指的是函数运行时， 所在的"环境";

`this`的设计目的就是在函数体内，指向函数当前的运行环境。

## 9.2  this多种不同指向

- 全局上下文 ——》window
- 函数上下文 ——》函数调用时所处的环境
- call、apply（）、bind（）——》绑定的元素
- 箭头函数    ——》箭头函数会捕获上下文中的this，作为自己的this值
- 在对象的一个方法中 ——》调用方法的对象
- 在构造函数中 ——》new出来那个对象
- DOM的事件处理函数中 ——》触发事件的DOM

# 10.instanceof 操作符

**原理：**

只要右边变量的 `prototype` 在左边变量的原型链上即可。

因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 false。

**手写一个instanceof：**

```javascript
function new_instance_of(leftValue, rightValue) {
    if(typeof leftValue !== 'object' || leftValue === null){
        return false;
    }
    let rightProto = rightValue.prototype;// 取右边表达式的prototype值
    leftValue = leftValue.__proto__;// 取左边表达式的__proto__
    while (true) {
        if (leftValue === null) {
            return false;
        }
        if (leftValue === rightProto) {
            return true;
        }
        // 遍历左边表达式的原型链
        leftValue = leftValue.__proto__;
    }
}
```

**参考链接**

- [浅谈 instanceof 和 typeof 的实现原理](https://juejin.cn/post/6844903613584654344)

# 
